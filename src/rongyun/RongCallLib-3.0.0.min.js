!(function (e, n) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = n() : typeof define === 'function' && define.amd ? define(n) : e.RongCallLib = n() }(this, function () { var RongIMLib = {RongIMClient: {}}, BlinkGlobal = {bandWidthCount: 0}, BlinkConstant = {SDK_VERSION_NAME: '1.0.0', LOGON_VERSION: '1', KEEPALIVE_INTERVAL: 5e3, KEEPALIVE_FAILEDTIMES_MAX: 4, KEEPALIVE_TIMER_INTERVAL: 1e3, KEEPALIVE_TIMER_TIMEOUT_MAX: 20, KEEPALIVE_TIMER_TIMEOUT_RECONNECT: 12, RECONNECT_MAXTIMES: 10, RECONNECT_TIMEOUT: 1e3, GETSTATSREPORT_INTERVAL: 1e3}, blinkengine; BlinkConstant.ConnectionType = {P2P: '0', MEDIASERVER: '1'}, BlinkConstant.UserType = {NORMAL: '1', OBSERVER: '2'}, BlinkConstant.ConnectionState = {CONNECTED: 'CONNECTED', DISCONNECTED: 'DISCONNECTED', ROOM_ERROR: 'ROOM_ERROR'}, BlinkConstant.wsConnectionState = {CONNECTED: 'CONNECTED', DISCONNECTED: 'DISCONNECTED', CONNECTING: 'CONNECTING'}, BlinkConstant.ExchangeType = {OFFER: '1', ANSWER: '2', CANDIDATE: '3'}, BlinkConstant.LogonAndJoinStatus = {CONNECT: 0, RECONNECT: 1}, BlinkConstant.OfferStatus = {SENDING: 'SENDING', DONE: 'DONE'}, BlinkConstant.Meeting = {RoleChange: {DEMOTION: 1, INVITE: 2, REMOVE: 3}, ChannelAnswer: {INVITE_OBSERVER: 1, OBSERVER_SPEAK: 2, INVITE_OPEN_DEV: 3, DEMOTIONUSER: 4, INVITE_CLOSE_DEV: 5}}, BlinkConstant.SignalType = {LOGONANDJOIN: 'logonAndJoin', CHANNEL_PING: 'channelPing', UPDATETALKTYPE: 'updateTalkType', LEAVE: 'leave', EWB_CREATE: 'ewb_create', EWB_QUERY: 'ewb_query', LOGONANDJOIN_RESULT: 'logonAndJoin_result', CHANNEL_PING_RESULT: 'channelPing_result', LEAVE_RESULT: 'leave_result', EWB_CREATE_RESULT: 'ewb_create_result', EWB_QUERY_RESULT: 'ewb_query_result', JOINED: 'joined', UPDATE_TALKTYPE: 'update_talktype', OFFER_REQUEST: 'offerRequest', LEFT: 'left', EWB_CREATE_NOTIFY: 'ewb_create_notify', FLOWSUBSCRIBE: 'flowSubscribe', EXCHANGE: 'exchange', EWB_CREATE_NOTIFY: 'ewb_create_notify', ROLECHANGE: 'rolechange', ROLECHANGE_RESULT: 'rolechange_result', APPLY: 'apply', APPLY_RESULT: 'apply_result', MANAGEACTION: 'manageaction', MANAGEACTION_RESULT: 'manageaction_result', CHANNELANSWER: 'channelanswer', CHANNELANSWER_RESULT: 'channelanswer_result', CREATENOTIFY: 'createnotify', CREATENOTIFY_RESULT: 'createnotify_result', EWBService: 'ewbservice', SCREENSHARING: 'screensharing', TURNTALKTYPE: 'turntalktype', TURNTALKTYPE_RESULT: 'turntalktype_result'}, BlinkConstant.VideoProfile_default = {width: 640, height: 480, frameRate: 15}, BlinkConstant.VideoProfile_min = {width: 176, height: 144, frameRate: 15}, BlinkConstant.ShareProfile_default = {width: 1280, height: 720, frameRate: 15}, BlinkConstant.BandWidth_default = {start: 500, min: 150, max: 600}, BlinkConstant.BandWidthAll = {BandWidth_240_min: 150, BandWidth_240_max: 300, BandWidth_320_min: 150, BandWidth_320_max: 300, BandWidth_480_min: 150, BandWidth_480_max: 600, BandWidth_640_min: 150, BandWidth_640_max: 600, BandWidth_720_min: 150, BandWidth_720_max: 2e3, BandWidth_1280_min: 150, BandWidth_1280_max: 2e3}, BlinkConstant.ParameterKey = {KEY_IS_AUDIO_ONLY: 'IS_AUDIO_ONLY', KEY_VIDEO_PROFILE: 'VIDEO_PROFILE', KEY_VIDEO_MAX_RATE: 'VIDEO_MAX_RATE', KEY_VIDEO_MIN_RATE: 'VIDEO_MIN_RAT', KEY_USER_TYPE: 'USER_TYPE', KEY_IS_CLOSE_VIDEO: 'IS_CLOSE_VIDEO'}; var BlinkEngine = function (e) { return this.init(e), this.initShare(), this.blinkMeeting = new BlinkMeeting(), blinkengine = this }; BlinkEngine.prototype.initShare = function () { this.addEventListener(), setTimeout(function () { window.postMessage('test', '*') }, 1e3) }, BlinkEngine.prototype.init = function (e) { this.channelId = null, this.peerConnections = {}, this.localStream = null, this.remoteStreams = new Array(), this.localAudioStream = null, this.logonAndJoinStatus = null, this.offerStatus = null, this.joinedUsers = new BlinkMap(), this.remoteCnameMap = new BlinkMap(), this.remoteSdpMap = new BlinkMap(), this.microphoneEnable = !0, this.localVideoEnable = !0, this.remoteAudioEnable = !0, this.keepAliveFailedTimes = 0, this.keepAliveInterval = null, this.keepAliveTimerCount = 0, this.keepAliveTimer = null, this.reconnectTimes = 0, this.csequence = 0, this.signaling = null, this.wsQueue = [], this.wsConnectionState = null, this.wsForcedClose = !1, this.wsNeedConnect = !0, this.wsUrlList = [], this.wsUrlIndex = 0, this.wsNavUrl = e, this.userType = BlinkConstant.UserType.NORMAL, this.isAudioOnly = !1, this.localVideoEnable = !0, this.videoProfile = BlinkConstant.VideoProfile_default, this.videoMinProfile = BlinkConstant.VideoProfile_min, this.videoMaxRate = BlinkConstant.BandWidth_default.max, this.videoMinRate = BlinkConstant.BandWidth_default.min, this.mediaConfig = {video: this.videoProfile, audio: !0}, this.mediaMinConfig = {video: this.videoMinProfile, audio: !1}, this.bandWidth = {min: this.videoMinRate, max: this.videoMaxRate}, this.ewbCreated = !1, this.isSendLostReport = !1, this.blinkConnectionStatsReport = null, this.getStatsReportInterval = null, this.isScreenShareSupport = !1 }, BlinkEngine.prototype.reset = function () {}, BlinkEngine.prototype.clear = function () { this.exitScheduleKeepAlive(), this.exitScheduleKeepAliveTimer(), this.disconnect(!1), this.closePeerConnection(this.selfUserId) }, BlinkEngine.prototype.getSDKVersion = function () { return BlinkConstant.SDK_VERSION_NAME }, BlinkEngine.prototype.setBlinkEngineEventHandle = function (e) { this.blinkEngineEventHandle = e }, BlinkEngine.prototype.setVideoParameters = function (e) { e.USER_TYPE != null && e.USER_TYPE == BlinkConstant.UserType.OBSERVER && (this.userType = BlinkConstant.UserType.OBSERVER), e.IS_AUDIO_ONLY != null && (this.isAudioOnly = e.IS_AUDIO_ONLY), e.IS_CLOSE_VIDEO != null && (this.localVideoEnable = !e.IS_CLOSE_VIDEO), e.VIDEO_PROFILE != null && (this.videoProfile = e.VIDEO_PROFILE, this.mediaConfig.video = this.videoProfile, this.videoProfile.width != null && this.videoProfile.height != null && (this.videoMinRate = BlinkConstant.BandWidthAll['BandWidth_' + this.videoProfile.width + '_min'], this.videoMaxRate = BlinkConstant.BandWidthAll['BandWidth_' + this.videoProfile.width + '_max'], this.videoMinRate = BlinkConstant.BandWidthAll['BandWidth_' + this.videoProfile.height + '_min'], this.videoMaxRate = BlinkConstant.BandWidthAll['BandWidth_' + this.videoProfile.height + '_max'], this.bandWidth.max = this.videoMaxRate, this.bandWidth.min = this.videoMinRate)) }, BlinkEngine.prototype.joinChannel = function (e, n, t) { this.channelId = BlinkConstant.ConnectionType.MEDIASERVER + e, this.selfUserId = n, this.token = t; var i = this; navigator.getUserMedia(i.mediaConfig, function (e) { BlinkLogger.info('navigator.getUserMedia success'), i.localStream = e, blinkengine.localStream.id = blinkengine.selfUserId, i.localVideoEnable || i.closeLocalVideoWithUpdateTalkType(!i.localVideoEnable, !1), i.createSignaling(), i.logonAndJoin(BlinkConstant.LogonAndJoinStatus.CONNECT) }, function (e) { BlinkLogger.error('navigator.getUserMedia error: ', e) }), navigator.getUserMedia(i.mediaMinConfig, function (e) { BlinkLogger.info('navigator.geMinMedia success'), e.id = i.selfUserId + '_tiny', i.localStreamMin = e }, function (e) { BlinkLogger.error('navigator.getMinMedia error: ', e) }) }, BlinkEngine.prototype.leaveChannel = function () { this.leave() }, BlinkEngine.prototype.getLocalVideoView = function () { return this.getLocalStream() }, BlinkEngine.prototype.getRemoteVideoView = function (e) { return this.getRemoteStream(e) }, BlinkEngine.prototype.getLocalStream = function () { return this.localStream }, BlinkEngine.prototype.getRemoteStream = function (e) { for (var n in this.remoteStreams) if (this.remoteStreams[n].id == e) return this.remoteStreams[n]; return null }, BlinkEngine.prototype.getRemoteStreamCount = function () { return this.remoteStreams.length }, BlinkEngine.prototype.createVideoView = function () { var e = document.createElement('video'); return e.autoplay = !0, e.setAttribute('playsinline', !0), e }, BlinkEngine.prototype.createLocalVideoView = function () { var e = this.createVideoView(); return e.muted = !0, e.id = this.selfUserId, e.srcObject = this.getLocalStream(), e }, BlinkEngine.prototype.createRemoteVideoView = function (e) { var n = this.getRemoteStream(e), t = this.createVideoView(); return t.id = e, t.srcObject = n, t }, BlinkEngine.prototype.muteMicrophone = function (e) { this.updateTalkTypeMic(e) }, BlinkEngine.prototype.closeLocalVideo = function (e) { this.updateTalkTypeCamera(e) }, BlinkEngine.prototype.closeLocalVideoWithUpdateTalkType = function (n, e) { this.localStream && this.localStream.getVideoTracks().forEach(function (e) { e.enabled = !n }), BlinkLogger.info('Local video close=' + n), this.localVideoEnable = !n }, BlinkEngine.prototype.closeRemoteAudio = function (e) { if (this.remoteStreams.length !== 0) { for (x = 0; x < this.remoteStreams.length; x++) { var n = this.remoteStreams[x]; if (n && n.getAudioTracks() && n.getAudioTracks().length > 0) for (y = 0; y < n.getAudioTracks().length; y++)n.getAudioTracks()[y].enabled = !e }BlinkLogger.info('Remote audio close=' + e), this.remoteAudioEnable = !e } else BlinkLogger.info('No remote audio available.') }, BlinkEngine.prototype.closeLocalStream = function () { if (this.localStream.getTracks() && this.localStream.getTracks().length === 0)BlinkLogger.info('No local track available.'); else { for (i = 0; i < this.localStream.getTracks().length; i++) this.localStream.getTracks()[i].stop(); if (this.localStreamMin.getTracks() && this.localStreamMin.getTracks().length === 0)BlinkLogger.info('No local track available.'); else for (i = 0; i < this.localStreamMin.getTracks().length; i++) this.localStreamMin.getTracks()[i].stop() } }, BlinkEngine.prototype.requestWhiteBoardURL = function () { this.ewb_create() }, BlinkEngine.prototype.queryWhiteBoard = function () { this.ewb_query() }, BlinkEngine.prototype.enableSendLostReport = function (e) { this.isSendLostReport = e }, BlinkEngine.prototype.startScreenShare = function () { var e = BlinkUtil.myBrowser(); ['Chrome'].indexOf(e) < 0 && this.blinkEngineEventHandle.call('onStartScreenShareComplete', {isSuccess: !1, code: 1}); var n = this; n.isScreenShareSupport ? n.requestScreenShare() : n.blinkEngineEventHandle.call('onStartScreenShareComplete', {isSuccess: !1, code: 2}) }, BlinkEngine.prototype.stopScreenShare = function () { var n = this; n.getLocalStreamFromRtcApi(n.mediaConfig).then(function (e) { n.localAudioStream.getTracks().forEach(function (e) { e.stop() }), e.getAudioTracks().forEach(function (e) { e.enabled = n.microphoneEnable }), n.screenSharingStatus = !1, n.screenOffer(e), BlinkUtil.setMediaStream(this.selfUserId, e), n.blinkEngineEventHandle.call('onStopScreenShareComplete', {isSuccess: !0}) }).catch(function (e) { BlinkLogger.error('stopScreenShare getLocalStreamFromRtcApi error: ' + e), n.blinkEngineEventHandle.call('onStopScreenShareComplete', {isSuccess: !1}) }) }, BlinkEngine.prototype.createSignaling = function () { if (this.wsConnectionState = BlinkConstant.wsConnectionState.CONNECTING, this.wsUrlList.length > 0) { this.wsUrlIndex++, this.wsUrlIndex > this.wsUrlList.length - 1 && (this.wsUrlIndex = 0); var e = this.wsUrlList[this.wsUrlIndex]; this.createSignalingWithUrl(e) } else { var i = this; BlinkUtil.getWsUrlList(this.wsNavUrl, function (e) { var n = e; if (n.length < 1) throw new Error('websocket连接失败!'); i.wsUrlList = BlinkUtil.shuffle(n); var t = i.wsUrlList[0]; i.createSignalingWithUrl(t) }) } }, BlinkEngine.prototype.createSignalingWithUrl = function (e) { var n = this; n.signaling = new WebSocket('wss://' + e + '/signaling'), n.signaling.onopen = function () { n.onOpen() }, n.signaling.onmessage = function (e) { n.onMessage(e) }, n.signaling.onerror = function (e) { n.onError(e) }, n.signaling.onclose = function (e) { n.onClose(e) } }; var BlinkMessage = function (e, n, t) { this.signal = e, this.content = n, this.parameters = t }; BlinkEngine.prototype.sendMsg = function (e, n, t) { this.csequence++, t.csequence = this.csequence; var i = JSON.stringify(new BlinkMessage(e, n, t)); this.send(i) }, BlinkEngine.prototype.send = function (e) { var n = JSON.parse(e).signal; this.wsConnectionState == BlinkConstant.wsConnectionState.CONNECTED ? (n == BlinkConstant.SignalType.CHANNEL_PING ? BlinkLogger.debug('req: ' + e) : BlinkLogger.info('req: ' + e), this.signaling.send(e)) : (BlinkLogger.warn('websocket not connected!'), this.wsQueue.length == 0 && n == BlinkConstant.SignalType.LOGONANDJOIN && this.wsQueue.push(e)) }, BlinkEngine.prototype.doWsQueue = function () { if (this.wsQueue.length > 0) { var e = this.wsQueue.shift(); this.send(e) } }, BlinkEngine.prototype.onOpen = function () { BlinkLogger.info('websocket open'), this.wsConnectionState = BlinkConstant.wsConnectionState.CONNECTED, this.reconnectTimes = 0, this.doWsQueue() }, BlinkEngine.prototype.onMessage = function (e) { var n = JSON.parse(e.data); switch (n.signal == BlinkConstant.SignalType.CHANNEL_PING_RESULT ? BlinkLogger.debug('res: ' + e.data) : BlinkLogger.info('res: ' + e.data), n.signal) { case BlinkConstant.SignalType.LOGONANDJOIN_RESULT:return void this.logonAndJoin_result(n); case BlinkConstant.SignalType.CHANNEL_PING_RESULT:return void this.channelPing_result(n); case BlinkConstant.SignalType.LEAVE_RESULT:return void this.leave_result(n); case BlinkConstant.SignalType.EWB_CREATE_RESULT:return void this.ewb_create_result(n); case BlinkConstant.SignalType.EWB_QUERY_RESULT:return void this.ewb_query_result(n); case BlinkConstant.SignalType.JOINED:return void this.joined(n); case BlinkConstant.SignalType.LEFT:return void this.left(n); case BlinkConstant.SignalType.OFFER_REQUEST:return void this.offerRequest(n); case BlinkConstant.SignalType.UPDATE_TALKTYPE:return void this.update_talktype(n); case BlinkConstant.SignalType.EXCHANGE:return void this.exchange(n); case BlinkConstant.SignalType.EWB_CREATE_NOTIFY:return void this.ewbCreateNotify(n); case BlinkConstant.SignalType.ROLECHANGE:return void this.blinkMeeting.roleChange(n); case BlinkConstant.SignalType.APPLY:return void this.blinkMeeting.applyMessage(n); case BlinkConstant.SignalType.MANAGEACTION:return void this.blinkMeeting.manageAction(n); case BlinkConstant.SignalType.CHANNELANSWER:return void this.blinkMeeting.channelAnswer(n); case BlinkConstant.SignalType.CREATENOTIFY:case BlinkConstant.SignalType.SCREENSHARING:return void console.info(n); case BlinkConstant.SignalType.TURNTALKTYPE:return void this.blinkMeeting.turntalktype(n); default:BlinkLogger.warn('Event ' + n.signal + ' do not have defined function', n.parameters) } }, BlinkEngine.prototype.onClose = function (e) { var n = this; BlinkLogger.warn('websocket close', e), e.code == 1e3 && e.reason == 'wsForcedClose' || (this.wsConnectionState = BlinkConstant.wsConnectionState.DISCONNECTED, this.wsNeedConnect && setTimeout(function () { n.reconnect() }, BlinkConstant.RECONNECT_TIMEOUT)) }, BlinkEngine.prototype.onError = function (e) { BlinkLogger.error('websocket error', e) }, BlinkEngine.prototype.disconnect = function (e) { BlinkLogger.warn('websocket disconnect'), BlinkLogger.warn('wsNeedConnect=' + e), this.wsForcedClose = !0, this.wsNeedConnect = e, this.wsConnectionState = BlinkConstant.wsConnectionState.DISCONNECTED, this.signaling.close(1e3, 'wsForcedClose'), this.wsNeedConnect && this.reconnect() }, BlinkEngine.prototype.reconnect = function () { if (this.wsConnectionState == BlinkConstant.wsConnectionState.DISCONNECTED) if (this.reconnectTimes++, BlinkLogger.warn('reconnectTimes=' + this.reconnectTimes), this.reconnectTimes > BlinkConstant.RECONNECT_MAXTIMES) this.keepAliveDisconnect(); else { var e = this; function n (e) { e.wsConnectionState == BlinkConstant.wsConnectionState.DISCONNECTED && (BlinkLogger.info('websocket reconnect'), e.createSignaling(), e.logonAndJoin(BlinkConstant.LogonAndJoinStatus.RECONNECT)) }e.reconnectTimes > 1 ? setTimeout(function () { n(e) }, BlinkConstant.RECONNECT_TIMEOUT) : n(e) } }, BlinkEngine.prototype.keepAlive = function () { this.wsConnectionState == BlinkConstant.wsConnectionState.CONNECTED ? (this.startScheduleKeepAliveTimer(), this.channelPing()) : this.keepAliveFailed() }, BlinkEngine.prototype.keepAliveFailed = function () { this.keepAliveFailedTimes++, BlinkLogger.warn('keepAliveFailedTimes=' + this.keepAliveFailedTimes), this.keepAliveFailedTimes > BlinkConstant.KEEPALIVE_FAILEDTIMES_MAX && this.keepAliveDisconnect() }, BlinkEngine.prototype.startScheduleKeepAlive = function () { this.exitScheduleKeepAlive(), this.exitScheduleKeepAliveTimer(); var e = this; e.keepAlive(), e.keepAliveInterval = setInterval(function () { e.keepAlive() }, BlinkConstant.KEEPALIVE_INTERVAL) }, BlinkEngine.prototype.exitScheduleKeepAlive = function () { this.keepAliveFailedTimes = 0, this.keepAliveInterval != null && (clearInterval(this.keepAliveInterval), this.keepAliveInterval = null) }, BlinkEngine.prototype.keepAliveTimerFunc = function () { this.keepAliveTimerCount++, this.keepAliveTimerCount > BlinkConstant.KEEPALIVE_TIMER_TIMEOUT_MAX / 3 ? BlinkLogger.warn('keepAliveTimerCount=' + this.keepAliveTimerCount) : BlinkLogger.debug('keepAliveTimerCount=' + this.keepAliveTimerCount), this.keepAliveTimerCount > BlinkConstant.KEEPALIVE_TIMER_TIMEOUT_MAX ? this.keepAliveDisconnect() : this.keepAliveTimerCount == BlinkConstant.KEEPALIVE_TIMER_TIMEOUT_RECONNECT && this.disconnect(!0) }, BlinkEngine.prototype.startScheduleKeepAliveTimer = function () { if (this.keepAliveTimer == null) { var e = this; e.keepAliveTimerCount += BlinkConstant.KEEPALIVE_INTERVAL / 1e3, e.keepAliveTimer = setInterval(function () { e.keepAliveTimerFunc() }, BlinkConstant.KEEPALIVE_TIMER_INTERVAL) } }, BlinkEngine.prototype.exitScheduleKeepAliveTimer = function () { this.keepAliveTimerCount = 0, this.keepAliveTimer != null && (clearInterval(this.keepAliveTimer), this.keepAliveTimer = null) }, BlinkEngine.prototype.keepAliveDisconnect = function () { this.clear(), this.blinkEngineEventHandle.call('onConnectionStateChanged', {connectionState: BlinkConstant.ConnectionState.DISCONNECTED}) }, BlinkEngine.prototype.getStatsReport = function () { var e = this.peerConnections[this.selfUserId]; if (e != null) { var n = e.pc, t = this; n.getStats(null, function (e) { t.blinkConnectionStatsReport.parseStatsReport(e), t.isSendLostReport && (BlinkLogger.debug('onNetworkSentLost=' + t.blinkConnectionStatsReport.packetSendLossRate), t.blinkEngineEventHandle.call('onNetworkSentLost', {packetSendLossRate: t.blinkConnectionStatsReport.packetSendLossRate})) }, function (e) { BlinkLogger.error('getStatsReport error: ', e) }) } }, BlinkEngine.prototype.startScheduleGetStatsReport = function () { this.exitScheduleGetStatsReport(), this.blinkConnectionStatsReport = new BlinkConnectionStatsReport(); var e = this; e.getStatsReportInterval = setInterval(function () { e.getStatsReport() }, BlinkConstant.GETSTATSREPORT_INTERVAL) }, BlinkEngine.prototype.exitScheduleGetStatsReport = function () { this.getStatsReportInterval != null && (clearInterval(this.getStatsReportInterval), this.getStatsReportInterval = null), this.blinkConnectionStatsReport = null }, BlinkEngine.prototype.addEventListener = function () { if (!this.isBindEvent) { var t = this; window.addEventListener('message', function (e) { var n = {onResponseReqSouId: function (e) { t.getLocalStreamFromRtcApi({video: !1, audio: !0}).then(function (e) { (t.localAudioStream = e).getAudioTracks().forEach(function (e) { e.enabled = t.microphoneEnable }) }).catch(function (e) { BlinkLogger.error('onResponseReqSouId getLocalStreamFromRtcApi error: ' + e), t.blinkEngineEventHandle.call('onStartScreenShareComplete', {isSuccess: !1}) }), t.getScreenStream(e.data.sourceId).then(function (e) { e.getVideoTracks()[0].onended = function () { t.stopScreenShare() }, t.screenShare(e) }).catch(function (e) { BlinkLogger.error('onResponseReqSouId getScreenStream error: ' + e), t.blinkEngineEventHandle.call('onStartScreenShareComplete', {isSuccess: !1}) }) }, testMessage: function (e) { t.isScreenShareSupport = !0 }, other: function (e) { BlinkLogger.info(e) }}; (n[e.data.type] || n.other)(e, t) }, !1), this.isBindEvent = !0 } }, BlinkEngine.prototype.requestScreenShare = function () { window.postMessage('requestScreenSourceId', '*') }, BlinkEngine.prototype.getLocalStreamFromRtcApi = function (t) { return new Promise(function (resolve, reject) { navigator.getUserMedia(t, e, n) }) }, BlinkEngine.prototype.getScreenStream = function (e) { var t = {mandatory: {chromeMediaSource: 'desktop', maxWidth: BlinkConstant.ShareProfile_default.width, maxHeight: BlinkConstant.ShareProfile_default.height, chromeMediaSourceId: e}, optional: [{googTemporalLayeredScreencast: !0}]}; return e = null, new Promise(function (resolve, reject) { navigator.getUserMedia({video: t}, e, n) }) }, BlinkEngine.prototype.screenShare = function (e) { this.screenSharingStatus = !0, this.screenOffer(e), BlinkUtil.setMediaStream(this.selfUserId, e), this.blinkEngineEventHandle.call('onStartScreenShareComplete', {isSuccess: !0}) }, BlinkEngine.prototype.screenOffer = function (e) { var n = this.localStream; this.localStream = e; var t = this.peerConnections[this.selfUserId]; if (t != null) { var i = t.pc; this.screenSharingStatus ? (i.addStream(this.localAudioStream), i.removeStream(this.localStreamMin)) : (i.removeStream(this.localAudioStream), i.addStream(this.localStreamMin)), i.removeStream(n), i.addStream(e), BlinkLogger.info('createOfferforShare'), this.createOffer(i, this.selfUserId, !0) }n.getTracks().forEach(function (e) { e.stop() }), this.localVideoEnable || this.closeLocalVideoWithUpdateTalkType(!this.localVideoEnable, !1) }, BlinkEngine.prototype.logonAndJoin = function (e) { this.logonAndJoinStatus = e == null || e == null ? 0 : e, this.offerStatus = null, this.sendMsg(BlinkConstant.SignalType.LOGONANDJOIN, this.token, {key: this.channelId, type: this.userType, index: this.localVideoEnable ? 1 : 0, status: this.logonAndJoinStatus, version: BlinkConstant.LOGON_VERSION}) }, BlinkEngine.prototype.channelPing = function () { this.sendMsg(BlinkConstant.SignalType.CHANNEL_PING, null, {key: this.channelId}) }, BlinkEngine.prototype.updateTalkType = function () { this.sendMsg(BlinkConstant.SignalType.UPDATETALKTYPE, null, {key: this.channelId, index: this.localVideoEnable ? 1 : 0}) }, BlinkEngine.prototype.updateTalkTypeCamera = function (e) { var n = !0; this.userType == BlinkConstant.UserType.OBSERVER && (n = !1), this.closeLocalVideoWithUpdateTalkType(e, n), this.sendMsg(BlinkConstant.SignalType.TURNTALKTYPE, null, {key: this.channelId, index: this.localVideoEnable ? 1 : 2, type: 1}) }, BlinkEngine.prototype.updateTalkTypeMic = function (n) { this.localStream && this.localStream.getAudioTracks().forEach(function (e) { e.enabled = !n }), this.localAudioStream && this.localAudioStream.getAudioTracks().forEach(function (e) { e.enabled = !n }), BlinkLogger.info('Microphone mute=' + n), this.microphoneEnable = !n, this.sendMsg(BlinkConstant.SignalType.TURNTALKTYPE, null, {key: this.channelId, index: this.microphoneEnable ? 1 : 2, type: 2}) }, BlinkEngine.prototype.leave = function () { this.sendMsg(BlinkConstant.SignalType.LEAVE, null, {key: this.channelId}) }, BlinkEngine.prototype.offer = function (e, n) { this.sendMsg(BlinkConstant.SignalType.EXCHANGE, e, {key: this.channelId, type: BlinkConstant.ExchangeType.OFFER, to: n}) }, BlinkEngine.prototype.answer = function (e, n) { this.sendMsg(BlinkConstant.SignalType.EXCHANGE, e, {key: this.channelId, type: BlinkConstant.ExchangeType.ANSWER, to: n}) }, BlinkEngine.prototype.candidate = function (e, n) { this.sendMsg(BlinkConstant.SignalType.EXCHANGE, e, {key: this.channelId, type: BlinkConstant.ExchangeType.CANDIDATE, to: n}) }, BlinkEngine.prototype.ewb_create = function () { this.sendMsg(BlinkConstant.SignalType.EWB_CREATE, null, {key: this.channelId}) }, BlinkEngine.prototype.ewb_query = function () { this.sendMsg(BlinkConstant.SignalType.EWB_QUERY, null, {key: this.channelId}) }, BlinkEngine.prototype.flowSubscribe = function (e) { this.sendMsg(BlinkConstant.SignalType.FLOWSUBSCRIBE, e, {key: this.channelId}) }, BlinkEngine.prototype.changeMicPhone = function (n, e) { this.localStream.getAudioTracks().forEach(function (e) { e.enabled = n }) }, BlinkEngine.prototype.changeVideo = function (n, e) { this.localStream.getVideoTracks().forEach(function (e) { e.enabled = n }) }; var channelHandler = {1: function (e) { console.error(e), blinkengine.blinkEngineEventHandle.call('onBecomeUser', {userId: e.parameters.from, userType: 1}) }, 2: function (e) { console.error(e); var n = e.parameters.serverData; e.parameters.status == 1 && n == blinkengine.selfUserId ? (console.error('fffffffffffffffffffffffff'), blinkengine.blinkMeeting.observerBecomeUser(n)) : blinkengine.blinkEngineEventHandle.call('onBecomeUser', {userId: n}) }, 3: function (e) { blinkengine.blinkEngineEventHandle.call('onUserAgreeOpen', {userId: e.parameters.from, type: e.parameters.type, userType: 1, status: e.parameters.status}) }, 4: function (n) { blinkengine.remoteStreams = blinkengine.remoteStreams.filter(function (e) { return e.id != n.parameters.from }), blinkengine.blinkEngineEventHandle.call('onUserDown', {userId: n.parameters.from, userType: 1}) }, 5: function (e) { blinkengine.blinkEngineEventHandle.call('onUserLeft5', {userId: e.to, userType: 1}) }, other: function (e) { console.warn('no handler to handle data', e) }}; BlinkEngine.prototype.closeStream = function (e) { e ? e.getTracks().forEach(function (e) { e.stop() }) : console.error(' stream is not exist') }, BlinkEngine.prototype.getPeerConnection = function (e) { var n = this.peerConnections[e].pc; if (!n) throw new Error('userId => peerConnection is not exist', e); return n }; var BlinkMeeting = function () {}; BlinkMeeting.prototype.turntalktype = function (e) { var n = e.parameters.type, t = e.parameters.index, i = e.parameters.serverData, o = blinkengine.getRemoteStream(i); t == 1 && n == 1 && o.getVideoTracks().forEach(function (e) { e.enabled = !0 }), blinkengine.blinkEngineEventHandle.call('onTurnTalkType', {userId: e.parameters.serverData, type: n, open: t == 1}) }, BlinkMeeting.prototype.channelAnswer = function (e) { var n = e.parameters.index || 'other'; (0, channelHandler[n])(e) }; var applyHandler = {1: function (e) { var n = e.parameters.from; blinkengine.blinkEngineEventHandle.call('OnReciveRequestToUser', {userId: n}) }, 2: function (e) { blinkengine.blinkEngineEventHandle.call('OnOtherUserBecomeHost', {hostId: e.parameters.from}) }, other: function (e) { console.warn('no handler to handle data', e) }}; BlinkMeeting.prototype.applyMessage = function (e) { var n = e.parameters.index; e.parameters.to; (0, applyHandler[n])(e) }, BlinkMeeting.prototype.roleChange = function (e) { var n = e.parameters.index, t = e.parameters.to; n == BlinkConstant.Meeting.RoleChange.DEMOTION ? this.noramlUserDoHostRequestDegradeNormalUserToObserver(t, !0) : n == BlinkConstant.Meeting.RoleChange.INVITE ? blinkengine.blinkEngineEventHandle.call('onBeRequestToUser', {hostId: e.parameters.to}) : n == BlinkConstant.Meeting.RoleChange.REMOVE && t == blinkengine.selfUserId && blinkengine.blinkEngineEventHandle.call('onHostRemoved', {userId: t}) }, BlinkMeeting.prototype.observerRequestBecomeNormalUser = function () { blinkengine.sendMsg(BlinkConstant.SignalType.APPLY, null, {key: blinkengine.channelId, index: 1}) }, BlinkMeeting.prototype.hostDoObserverRequestBecomeNormalUser = function (e, n) { blinkengine.sendMsg(BlinkConstant.SignalType.CHANNELANSWER, null, {key: blinkengine.channelId, to: e, index: 2, status: n}) }, BlinkMeeting.prototype.hostRequestNormalUserToObserver = function (e) { blinkengine.sendMsg(BlinkConstant.SignalType.ROLECHANGE, null, {key: blinkengine.channelId, to: e, index: 1}) }, BlinkMeeting.prototype.noramlUserDoHostRequestDegradeNormalUserToObserver = function (e, n) { blinkengine.sendMsg(BlinkConstant.SignalType.CHANNELANSWER, null, {key: blinkengine.channelId, to: e, index: 4, status: 1}), blinkengine.closeStream(blinkengine.localStream); var t = blinkengine.getPeerConnection(blinkengine.selfUserId); t.removeStream(blinkengine.localStream), blinkengine.createOffer(t, blinkengine.selfUserId, !1), blinkengine.blinkEngineEventHandle.call('onUserDown', {userId: e}) }; var deviceControl = {1: function (e) { blinkengine.changeVideo(e) }, 2: function (e) { blinkengine.changeMicPhone(e) }}; BlinkMeeting.prototype.userDoHostRequestControlUserDevice = function (e, n, t, i) { var o = n ? 3 : 5; (0, deviceControl[t = t])(n), blinkengine.sendMsg(BlinkConstant.SignalType.CHANNELANSWER, null, {key: blinkengine.channelId, to: e, index: o, type: t, status: i}) }, BlinkMeeting.prototype.hostUpUser = function (e) { blinkengine.sendMsg(BlinkConstant.SignalType.ROLECHANGE, null, {key: blinkengine.channelId, to: e, index: 2}) }, BlinkMeeting.prototype.observerBecomeUser = function (e) { var t = blinkengine; blinkengine.getLocalStreamFromRtcApi(blinkengine.mediaConfig).then(function (e) { blinkengine.localStream = e; var n = blinkengine.getPeerConnection(blinkengine.selfUserId); n.addStream(e), blinkengine.createOffer(n, blinkengine.selfUserId, !1), BlinkUtil.refreshMediaStream(blinkengine.selfUserId), blinkengine.blinkEngineEventHandle.call('onBecomeUser', {userId: blinkengine.selfUserId, stream: blinkengine.localStream}), !t.localVideoEnable && t.microphoneEnable || (t.localVideoEnable && t.microphoneEnable || t.localVideoEnable && t.microphoneEnable), blinkengine.localVideoEnable = !0, blinkengine.microphoneEnable = !0, blinkengine.blinkEngineEventHandle.call('onaddstream', {userId: blinkengine.selfUserId, stream: blinkengine.localStream, userType: BlinkConstant.UserType.NORMAL, talkType: 1, isLocal: !1}) }) }, BlinkMeeting.prototype.doHostRequestToUser = function (e, n) { var t = n == 1 ? 1 : 2; t == 1 && this.observerBecomeUser(this.selfUserId), blinkengine.sendMsg(BlinkConstant.SignalType.CHANNELANSWER, null, {key: blinkengine.channelId, to: e, index: 1, status: t}) }, BlinkMeeting.prototype.hostRemoveUser = function (e) { blinkengine.sendMsg(BlinkConstant.SignalType.ROLECHANGE, null, {key: blinkengine.channelId, to: e, index: 3}) }, BlinkMeeting.prototype.screenShare = function (e) { e = e == 1 ? 1 : 2; blinkengine.sendMsg(BlinkConstant.SignalType.SCREENSHARING, null, {key: blinkengine.channelId, index: e}) }; var manageActionHandler = {1: function (e) { blinkengine.blinkEngineEventHandle.call('OnHostRequestControlDevice', {userId: e.parameters.to, content: e.parameters}) }, 2: function (e) { blinkengine.blinkEngineEventHandle.call('OnHostRequestControlDevice', {userId: e.parameters.to, content: e.parameters}) }, other: function (e) { console.warn('no handler to handle data', e) }}; BlinkMeeting.prototype.manageAction = function (e) { var n = e.parameters.index; e.parameters.to; (0, manageActionHandler[n])(e) }, BlinkMeeting.prototype.hostRequestControlUserDevice = function (e, n, t) { blinkengine.sendMsg(BlinkConstant.SignalType.MANAGEACTION, null, {key: blinkengine.channelId, to: e, index: t, type: n}) }, BlinkMeeting.prototype.getHostPower = function () { blinkengine.sendMsg(BlinkConstant.SignalType.APPLY, null, {key: blinkengine.channelId, index: 2}) }, BlinkMeeting.prototype.GetInviteUrl = function () {}, BlinkEngine.prototype.myBrowser = function () { var e = navigator.userAgent, n = e.indexOf('Opera') > -1; return n ? 'Opera' : e.indexOf('Firefox') > -1 ? 'FF' : e.indexOf('Chrome') > -1 ? 'Chrome' : e.indexOf('Safari') > -1 ? 'Safari' : e.indexOf('compatible') > -1 && e.indexOf('MSIE') > -1 && !n ? 'IE' : void 0 }, BlinkEngine.prototype.initShare = function () { this.addEventListener(), localStorage.shared && localStorage.removeItem('shared'), setTimeout(function () { window.postMessage('test', '*') }, 1e3) }, BlinkEngine.prototype.startShare = function () { var t = this; return new Promise(function (resolve, reject) { t.supportShareScreen() || n({code: 1}), localStorage.shared ? e({code: 0}) : n({code: 2}) }) }; var messageHandler = {onResponseReqSouId: function (e, n) { n.getLocalStreamFromRtcApi({video: !1, audio: !0}).then(function (e) { (n.localAudioStream = e).getAudioTracks().forEach(function (e) { e.enabled = n.microphoneEnable }) }).catch(function (e) { BlinkLogger.error(e) }), n.getScreenStream(e.data.sourceId).then(function (e) { e.getVideoTracks()[0].onended = function () { n.endShareScreen() }, BlinkConstant.ShareScreen = !0, n.screenOffer(e), blinkEngine.blinkEngineEventHandle.call('onShareComplete', {isJoined: !1}) }).catch(function (e) { BlinkLogger.error(e) }) }, testMessage: function (e) { localStorage.setItem('shared', !0) }, other: function (e) { console.log(e) }}; BlinkEngine.prototype.shareWithStream = function (n) { this.blinkMeeting.screenShare(!0), blinkengine.getLocalStreamFromRtcApi({video: !1, audio: !0}).then(function (e) { (blinkengine.localAudioStream = e).getAudioTracks().forEach(function (e) { e.enabled = blinkengine.microphoneEnable }), n.getVideoTracks()[0].onended = function () { blinkengine.endShareScreen() }, BlinkConstant.ShareScreen = !0, blinkengine.screenOffer(n) }).catch(function (e) { BlinkLogger.error(e) }) }, BlinkEngine.prototype.addEventListener = function (e) { var n = this; window.addEventListener('message', function (e) { (messageHandler[e.data.type] || messageHandler.other)(e, n) }, !1) }, BlinkEngine.prototype.getLocalStreamFromRtcApi = function (t) { return new Promise(function (resolve, reject) { navigator.getUserMedia(t, e, n) }) }, BlinkEngine.prototype.getScreenStream = function (e) { var t = {mandatory: {chromeMediaSource: 'screen', maxWidth: BlinkConstant.ShareProfile_default.width, maxHeight: BlinkConstant.ShareProfile_default.height, chromeMediaSourceId: e}, optional: [{googTemporalLayeredScreencast: !0}]}; return e = null, new Promise(function (resolve, reject) { navigator.getUserMedia({video: t}, e, n) }) }, BlinkEngine.prototype.screenOffer = function (e, n) { var t = this.localStream; this.localStream = e; var i = this.peerConnections[this.selfUserId]; if (i != null) { var o = i.pc; BlinkConstant.ShareScreen ? this.localAudioStream && o.addStream(this.localAudioStream) : this.localAudioStream && o.removeStream(this.localAudioStream), o.removeStream(t), o.addStream(e), BlinkLogger.log(' createOfferforShare'), this.createOffer(o, this.selfUserId, !0) } this.localVideoEnable || this.closeLocalVideoWithUpdateTalkType(!this.localVideoEnable, !1) }, BlinkEngine.prototype.supportShareScreen = function () { var e = this.myBrowser(); return ['Chrome'].indexOf(e) >= 0 }, BlinkEngine.prototype.shareScreen = function (e) { window.postMessage('requestScreenSourceId', '*') }, BlinkEngine.prototype.endShareScreen = function () { this.blinkMeeting.screenShare(!1); var t = this; t.getLocalStreamFromRtcApi(t.mediaConfig).then(function (e) { var n; t.localAudioStream && t.localAudioStream.getTracks().forEach(function (e) { e.stop() }), e.getAudioTracks().forEach(function (e) { e.enabled = t.microphoneEnable }), BlinkConstant.ShareScreen = !1, t.screenOffer(e), n = !t.localVideoEnable && t.microphoneEnable ? 0 : t.localVideoEnable && t.microphoneEnable ? 1 : t.localVideoEnable && !t.microphoneEnable ? 2 : 3, blinkengine.blinkEngineEventHandle.call('onShareComplete', {isShared: !1, stream: blinkengine.localStream, userId: blinkengine.selfUserId, talkType: n}) }) }, BlinkEngine.prototype.logonAndJoin_result = function (data) { var statusCode = data.parameters.statusCode, isJoined = statusCode == 'OK'; if (isJoined) { var content = data.content, contentArr = content.split('],'), member = contentArr.length > 1 ? contentArr[1] : contentArr[0], memberArr = eval(member); for (var i in memberArr) { var userId = memberArr[i].userId; if (!this.joinedUsers.contains(userId)) { var userType = memberArr[i].type, talkType = memberArr[i].talktype, joinedUser = new Array(); joinedUser.push(userType), joinedUser.push(talkType), joinedUser.push(null), this.joinedUsers.put(userId, joinedUser) } } if (this.startScheduleKeepAlive(), this.logonAndJoinStatus == BlinkConstant.LogonAndJoinStatus.RECONNECT) { var pcClient = this.peerConnections[this.selfUserId]; if (pcClient != null) { var pc = pcClient.pc; BlinkLogger.warn('reLogonAndJoin createOffer'), this.createOffer(pc, this.selfUserId, !0) } } } var joinedUser = this.joinedUsers.get(this.selfUserId), talkType = joinedUser[1]; this.logonAndJoinStatus != BlinkConstant.LogonAndJoinStatus.CONNECT && (this.logonAndJoinStatus != BlinkConstant.LogonAndJoinStatus.RECONNECT || isJoined) && this.onJoinComplete || (this.blinkEngineEventHandle.call('onJoinComplete', {isJoined: isJoined, userId: this.selfUserId, talkType: talkType}), this.onJoinComplete = !0) }, BlinkEngine.prototype.channelPing_result = function (e) { this.exitScheduleKeepAliveTimer(), e.parameters.statusCode == 'OK' ? this.keepAliveFailedTimes = 0 : this.keepAliveFailed() }, BlinkEngine.prototype.leave_result = function (e) { var n = e.parameters.statusCode == 'OK'; n && this.clear(), this.blinkEngineEventHandle.call('onLeaveComplete', {isLeft: n}) }, BlinkEngine.prototype.ewb_create_result = function (e) { var n = e.parameters.statusCode == 'OK', t = ''; n && (t = e.content), this.blinkEngineEventHandle.call('onWhiteBoardURL', {isSuccess: n, url: t}) }, BlinkEngine.prototype.ewb_query_result = function (e) { var n = e.parameters.statusCode == 'OK', t = ''; n && (t = e.content) && (this.ewbCreated = !0), this.blinkEngineEventHandle.call('onWhiteBoardQuery', {isSuccess: n, url: t}) }, BlinkEngine.prototype.joined = function (e) { var n = e.parameters.serverData, t = e.parameters.type, i = e.parameters.index; if (!this.joinedUsers.contains(n)) { var o = new Array(); o.push(t), o.push(i), o.push(null), this.joinedUsers.put(n, o) } this.blinkEngineEventHandle.call('onUserJoined', {userId: n, userType: t, talkType: i}) }, BlinkEngine.prototype.update_talktype = function (e) { var n = e.parameters.serverData, t = e.parameters.type, i = e.parameters.index; this.blinkEngineEventHandle.call('onUserUpdatedTalkType', {userId: n, userType: t, talkType: i}) }, BlinkEngine.prototype.turnTalkType = function (e, n, t) { this.sendMsg(BlinkConstant.SignalType.TURNTALKTYPE, null, {key: this.channelId, serverdata: e, index: n, type: t}) }, BlinkEngine.prototype.left = function (e) { var n = e.parameters.serverData, t = e.parameters.type; if (t == BlinkConstant.UserType.NORMAL) for (var i in this.remoteStreams) if (this.remoteStreams[i].id == n) { this.remoteStreams.splice(i, 1); break } this.joinedUsers.remove(n), this.remoteCnameMap.remove(n), this.remoteSdpMap.remove(n), this.joinedUsers.size() == 1 && (this.offerStatus = null, this.closePeerConnection(this.selfUserId)), this.blinkEngineEventHandle.call('onUserLeft', {userId: n, userType: t}) }, BlinkEngine.prototype.preparePeerConnection = function (i) { BlinkLogger.info('preparePeerConnection userId=' + i); var o = this; if (o.peerConnections[i] == null) { var n = new RTCPeerConnection(), e = new RTCPeerConnection(); n.onaddstream = function (e) { BlinkLogger.debug('onaddstream', e); var n = o.joinedUsers.get(e.stream.id); n.splice(2, 1, e.stream); var t = n[1]; console.log('talkType', t), t != 0 && t != 3 || (console.log('remove Video track', t), e.stream.getVideoTracks().forEach(function (e) { e.enabled = !1 })), o.remoteStreams.push(e.stream), o.blinkEngineEventHandle.call('onaddstream', {userId: e.stream.id, userType: BlinkConstant.UserType.NORMAL, talkType: t, stream: e.stream, isLocal: !1}) }, n.onremovestream = function (e) { BlinkLogger.debug('onremovestream', e) }, n.ontrack = null, n.onsignalingstatechange = function (e) { BlinkLogger.debug('onsignalingstatechange', e) }, n.oniceconnectionstatechange = function (e) { BlinkLogger.debug('oniceconnectionstatechange', e), BlinkLogger.warn('pc.iceConnectionState=' + n.iceConnectionState), n.iceConnectionState == 'failed' && o.wsConnectionState == BlinkConstant.wsConnectionState.CONNECTED && (BlinkLogger.warn('oniceconnectionstatechange createOffer'), o.createOffer(n, i, !0)) }, n.onnegotiationneeded = null, n.ondatachannel = null, n.onicecandidate = function (e) { BlinkLogger.debug('onicecandidate', e), (function e (n, t) { if ((n.signalingState || n.readyState) == 'stable' && o.peerConnections[i].rem == 1) return void (t.candidate && o.candidate(JSON.stringify(t.candidate), i)); setTimeout(function () { e(n, t) }, 2e3) }(n, e)) }, o.peerConnections[i] = {}, o.peerConnections[i].pc = n, o.peerConnections[i].pcMin = e, o.peerConnections[i].rem = !1 } return o.peerConnections[i] }, BlinkEngine.prototype.closePeerConnection = function (e) { this.peerConnections[e] != null && (this.peerConnections[e].pc.close(), this.peerConnections[e] = null), this.exitScheduleGetStatsReport() }, BlinkEngine.prototype.offerRequest = function (e) { var n = e.parameters.serverData, t = this.preparePeerConnection(n).pc; this.userType == BlinkConstant.UserType.NORMAL && (t.addStream(this.localStream), BlinkConstant.ShareScreen && t.addStream(this.localAudioStream)), e.parameters.type && e.parameters.type, BlinkLogger.warn('offerRequest createOffer'), this.createOffer(t, n, !1) }, BlinkEngine.prototype.exchange = function (e) { var n = e.parameters.type; n == BlinkConstant.ExchangeType.OFFER ? this.handleOffer(e) : n == BlinkConstant.ExchangeType.ANSWER ? this.handleAnswer(e) : n == BlinkConstant.ExchangeType.CANDIDATE && this.handleCandidate(e) }, BlinkEngine.prototype.ewbCreateNotify = function (e) { this.ewbCreated = !0 }, BlinkEngine.prototype.handleOffer = function (e) { if (this.offerStatus != BlinkConstant.OfferStatus.SENDING) { var n = e.parameters.from, t = JSON.parse(e.content.replace(new RegExp(''', 'g'), ''')); t.sdp = BlinkUtil.setBandWidth(t.sdp, this.bandWidth); var i = this.preparePeerConnection(n), o = i.pc; this.userType == BlinkConstant.UserType.NORMAL && o.addStream(this.localStream); var r = this; o.setRemoteDescription(new RTCSessionDescription(t), function () { BlinkLogger.info('handleOffer setRemoteDescription success'), r.offerStatus = BlinkConstant.OfferStatus.DONE, r.setRemoteCnameMap(t.sdp), i.rem = !0, o.createAnswer(function (e) { BlinkLogger.info('createAnswer success'), o.setLocalDescription(e, function () { BlinkLogger.info('createAnswer setLocalDescription success'), r.answer(JSON.stringify(e), n) }, function (e) { BlinkLogger.error('createAnswer setLocalDescription error: ', e) }) }, function (e) { BlinkLogger.error('createAnswer error: ', e) }, r.getSdpMediaConstraints(!1)) }, function (e) { BlinkLogger.error('handleOffer setRemoteDescription error: ', e) }) } else BlinkLogger.warn('handleOffer offerStatus sending') }, BlinkEngine.prototype.handleAnswer = function (e) { if (this.offerStatus != BlinkConstant.OfferStatus.DONE) { var n, t = e.parameters.from, i = JSON.parse(e.content.replace(new RegExp(''', 'g'), ''')), o = this.preparePeerConnection(t); n = o.pc, i.sdp = BlinkUtil.setBandWidth(i.sdp, this.bandWidth); var r = this; n.setRemoteDescription(new RTCSessionDescription(i), function () { BlinkLogger.info('handleAnswer setRemoteDescription success'), r.offerStatus = BlinkConstant.OfferStatus.DONE, r.setRemoteCnameMap(i.sdp), o.rem = !0 }, function (e) { BlinkLogger.error('handleAnswer setRemoteDescription error: ', e) }) } else BlinkLogger.warn('handleAnswer offerStatus done') }, BlinkEngine.prototype.handleCandidate = function (e) { var n = e.parameters.from, t = JSON.parse(e.content.replace(new RegExp(''', 'g'), ''')); this.preparePeerConnection(n).pc.addIceCandidate(new RTCIceCandidate(t), function () { BlinkLogger.info('addIceCandidate success') }, function (e) { BlinkLogger.error('addIceCandidate error: ', e) }) }, BlinkEngine.prototype.createOffer = function (n, t, e) { if (this.offerStatus != BlinkConstant.OfferStatus.SENDING) { BlinkLogger.info('createOffer userId=' + t); var i = this; n.createOffer(function (e) { BlinkLogger.info('createOffer success'), e.sdp = BlinkUtil.changeStreamId(e.sdp, i.localStream.id, i.selfUserId), i.minStream && !i.screenSharingStatus && (e.sdp = BlinkUtil.changeStreamId(e.sdp, i.localStreamMin.id, i.selfUserId + '_tiny')), BlinkConstant.ShareScreen && blinkengine.localAudioStream && (e.sdp = BlinkUtil.changeStreamId(e.sdp, i.localAudioStream.id, i.selfUserId)), e.sdp = BlinkUtil.changeVideoDesc(e.sdp), n.setLocalDescription(e, function () { BlinkLogger.info('createOffer setLocalDescription success'), i.offerStatus = BlinkConstant.OfferStatus.SENDING, i.offer(JSON.stringify(e), t) }, function (e) { BlinkLogger.error('createOffer setLocalDescription error: ', e) }) }, function (e) { BlinkLogger.error('createOffer error: ', e) }, i.getSdpMediaConstraints(e)) } else BlinkLogger.warn('createOffer offerStatus sending') }, BlinkEngine.prototype.getSdpMediaConstraints = function (e) { var n = {mandatory: {}}; return n.mandatory.OfferToReceiveAudio = !0, n.mandatory.OfferToReceiveVideo = !0, BlinkLogger.warn('isIceRestart=' + e), n.mandatory.IceRestart = e, n }, BlinkEngine.prototype.setRemoteCnameMap = function (e) { var n = this.joinedUsers.getEntrys(); for (var t in n) { var i, o = n[t].key; if (o != this.selfUserId) if (this.remoteCnameMap.contains(o)) if ((i = this.remoteCnameMap.get(o)) == null || i == '' || BlinkUtil.isHasCname(e, i)) { if (i != null && i != '' && BlinkUtil.isHasCname(e, i)) { var r; if (i == (r = BlinkUtil.getCname(e, o))) { var a = this.remoteSdpMap.get(o); BlinkUtil.getSsrc(a, o, i) != BlinkUtil.getSsrc(e, o, i) && BlinkUtil.refreshMediaStream(o) } } } else (r = BlinkUtil.getCname(e, o)) != null && r != '' && (this.remoteCnameMap.put(o, r), BlinkUtil.refreshMediaStream(o)); else (i = BlinkUtil.getCname(e, o)) != null && i != '' && (this.remoteCnameMap.put(o, i), this.remoteSdpMap.put(o, e)) } }; var BlinkEngineEventHandle = function (e) { return this.eventHandles = {}, this }; BlinkEngineEventHandle.prototype.on = function (e, n) { this.eventHandles[e] = n }, BlinkEngineEventHandle.prototype.call = function (e, n) { for (var t in this.eventHandles) if (e === t) return this.eventHandles[e](n); BlinkLogger.info('EventHandle ' + e + ' do not have defined function') }; var BlinkConnectionStatsReport = function () { this.statsReportSend = {}, this.statsReportRecvs = new Array(), this.packetSendLossRate = 0 }; BlinkConnectionStatsReport.prototype.parseStatsReport = function (e) { var n = this.statsReportSend.packetsSent; n = n == null || n == '' ? 0 : n; var t = this.statsReportSend.packetsLost; t = t == null || t == '' ? 0 : t; var i = 0, o = {}, r = new Array(); for (var a in e) { var s = e[a]; if (s.type == 'ssrc' && s.mediaType == 'video') if (s.id.indexOf('recv') != -1) { var l = {}; l.googTrackId = s.googTrackId, l.googCodecName = s.googCodecName, l.googCurrentDelayMs = s.googCurrentDelayMs, l.googDecodeMs = s.googDecodeMs, l.googFrameHeightReceived = s.googFrameHeightReceived, l.googFrameRateDecoded = s.googFrameRateDecoded, l.googFrameRateOutput = s.googFrameRateOutput, l.googFrameRateReceived = s.googFrameRateReceived, l.googFrameWidthReceived = s.googFrameWidthReceived, l.packetsLost = s.packetsLost, l.packetsReceived = s.packetsReceived, r.push(l) } else s.id.indexOf('send') != -1 && (o.googCodecName = s.googCodecName, o.googAvgEncodeMs = s.googAvgEncodeMs, o.googFrameHeightInput = s.googFrameHeightInput, o.googFrameHeightSent = s.googFrameHeightSent, o.googFrameRateSent = s.googFrameRateSent, o.googFrameWidthInput = s.googFrameWidthInput, o.googFrameWidthSent = s.googFrameWidthSent, o.googFrameRateInput = s.googFrameRateInput, o.packetsLost = s.packetsLost, o.packetsSent = s.packetsSent, o.packetsLost != null && o.packetsLost != '' && o.packetsSent != null && o.packetsSent != '' && o.packetsSent - n != 0 && (i = 100 * (o.packetsLost - t) / (o.packetsSent - n))) } this.statsReportSend = null, this.statsReportRecvs = null, this.packetSendLossRate = 0, this.statsReportSend = o, this.statsReportRecvs = r, BlinkLogger.debug('packetSendLossRate=' + i), this.packetSendLossRate = parseInt(i), BlinkLogger.debug('this.packetSendLossRate=' + this.packetSendLossRate) }; var BlinkVideoView = function () {}, BlinkUtil = {getWsUrlList: function (e, n) { BlinkAjax({type: 'GET', url: e, async: !0, data: {rand: Math.random()}, dataType: 'JSON', success: function (e) { n(e) }, error: function (e) { throw BlinkLogger.error('request nav error: ', e), e }}) }, setBandWidth: function (e, n) { BlinkGlobal.bandWidthCount++; var t = JSON.parse(JSON.stringify(n)); BlinkGlobal.bandWidthCount % 2 == 0 && (t.min = t.min + 1); var i = (e = e.replace(/a=mid:video\n/g, 'a=mid:video\nb=AS:' + t.max + '\n')).split('\n'), o = BlinkUtil.findLine(i, 'm=video'); if (o == null) return e; var r = i[o].split(' ')[3], a = 'a=rtpmap:' + r, s = BlinkUtil.findLine(i, a); if (s == null) return e; var l = 'a=fmtp:' + r + ' x-google-min-bitrate=' + t.min + '; x-google-max-bitrate=' + t.max; return i[s] = i[s].concat('\n' + l), i.join('\n') }, changeStreamId: function (e, n, t) { return e = e.replace(new RegExp(n, 'g'), t) }, changeVideoDesc: function (e) { var n = '\r\n', t = e.split(n), i = BlinkUtil.findLine(t, 'm=video'); if (i == null) return e; var o = ' ', r = t[i].split(o), a = r[0] + o + r[1] + o + r[2], s = BlinkUtil.findLineInRange(t, 'a=rtpmap', i + 1, t.length - 1), l = BlinkUtil.findLineInRange(t, 'a=ssrc-group', s + 1, t.length - 1); l == null && (l = t.length - 1); var c = t.splice(s, l - s), d = BlinkUtil.findLine(c, 'H264/90000'), u = BlinkUtil.findLine(c, 'VP8/90000'), g = BlinkUtil.findLine(c, 'red/90000'), p = ''; return d != null && (a += ' 98', p += n + 'a=rtpmap:98 H264/90000\r\na=rtcp-fb:98 ccm fir\r\na=rtcp-fb:98 nack\r\na=rtcp-fb:98 nack pli\r\na=rtcp-fb:98 goog-remb\r\na=rtcp-fb:98 transport-cc\r\na=fmtp:98 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01f\r\na=rtpmap:99 rtx/90000\r\na=fmtp:99 apt=98'), u != null && (a += ' 96', p += n + 'a=rtpmap:96 VP8/90000\r\na=rtcp-fb:96 ccm fir\r\na=rtcp-fb:96 nack\r\na=rtcp-fb:96 nack pli\r\na=rtcp-fb:96 goog-remb\r\na=rtcp-fb:96 transport-cc\r\na=rtpmap:97 rtx/90000\r\na=fmtp:97 apt=96'), g != null && (a += ' 100', p += n + 'a=rtpmap:100 red/90000\r\na=rtpmap:101 rtx/90000\r\na=fmtp:101 apt=100'), BlinkUtil.findLine(c, 'ulpfec/90000') != null && (a += ' 127', p += n + 'a=rtpmap:127 ulpfec/90000'), BlinkUtil.findLine(c, 'flexfec-03/90000') != null && (a += ' 125', p += n + 'a=rtpmap:125 flexfec-03/90000\r\na=rtcp-fb:125 transport-cc\r\na=rtcp-fb:125 goog-remb\r\na=fmtp:125 repair-window=10000000'), d != null && (a += ' 99'), u != null && (a += ' 97'), g != null && (a += ' 101'), t[i] = a, t[s - 1] = t[s - 1].concat(p), t.join(n) }, getCname: function (e, n) { var t = e.split('\n'), i = 'msid:' + n, o = BlinkUtil.findLine(t, i); if (o == null) return null; var r = t[o].split(' ')[0] + ' cname:'; return t[BlinkUtil.findLine(t, r)].split('cname:')[1] }, isHasCname: function (e, n) { var t = e.split('\n'), i = 'cname:' + n; return BlinkUtil.findLine(t, i) != null }, getSsrc: function (e, n, t) { var i = e.split('\n'), o = i.map(function (e, n) { if (e.indexOf('mid:video') > -1) return n }).filter(function (e) { return e }), r = (i = i.slice(o[0])).filter(function (e) { return e.indexOf('a=ssrc:') > -1 }), a = r.map(function (e, n) { if (e.indexOf('cname:' + t) > -1) return n }).filter(function (e) { return e }); return r.slice(a[0] + 1, a[0] + 2)[0].split(' ')[2] }, findLine: function (e, n) { for (var t = 0; t < e.length; t++) if (e[t].indexOf(n) != -1) return t; return null }, findLineInRange: function (e, n, t, i) { for (var o = t == null || t == '' || t < 0 ? 0 : t, r = i == null || i == '' || i < 0 || i > e.length - 1 ? e.length - 1 : i, a = o = r < o ? r : o; a <= r; a++) if (e[a].indexOf(n) != -1) return a; return null }, shuffle: function (e) { for (var n = e.length - 1; n >= 0; n--) { var t = Math.floor(Math.random() * (n + 1)), i = e[t]; e[t] = e[n], e[n] = i } return e }, refreshMediaStream: function (n) { var e = document.getElementById(n); if (e != null) { var t = n == blinkengine.selfUserId ? blinkengine.localStream : blinkengine.remoteStreams.filter(function (e) { return e.id == n })[0]; e.srcObject = t, e.srcObject = e.srcObject } }, setMediaStream: function (e, n) { var t = document.getElementById(e); t != null && (t.srcObject = n) }, myBrowser: function () { var e = navigator.userAgent, n = e.indexOf('Opera') > -1; return n ? 'Opera' : e.indexOf('Firefox') > -1 ? 'FF' : e.indexOf('Chrome') > -1 ? 'Chrome' : e.indexOf('Safari') > -1 ? 'Safari' : e.indexOf('compatible') > -1 && e.indexOf('MSIE') > -1 && !n ? 'IE' : void 0 }}, BlinkAjax = function (opt) { function init (e) { var n = {url: '', type: 'GET', data: {}, async: !0, dataType: 'JSON', success: function () {}, error: function (e) {}}; return e.url = e.url || n.url, e.type = e.type.toUpperCase() || n.method, e.data = params(e.data) || params(n.data), e.dataType = e.dataType.toUpperCase() || n.dataType, e.success = e.success || n.success, e.error = e.error || n.error, e } function createXHR () { if (window.XMLHttpRequest) return new XMLHttpRequest(); if (!window.ActiveXObject) throw new Error('浏览器不支持XHR对象！'); for (var e = 0, n = ['MSXML2.XMLHttp', 'Microsoft.XMLHTTP'].length; e < n; e++) try { return new ActiveXObject(version[e]) } catch (e) {} } function params (e) { var n = []; for (var t in e)n.push(encodeURIComponent(t) + '=' + encodeURIComponent(e[t])); return n.join('&') } function callback (opt, xhr) { if (xhr.readyState == 4 && xhr.status == 200) { var returnValue; switch (opt.dataType) { case 'XML':returnValue = xhr.responseXML; break; case 'JSON':var jsonText = xhr.responseText; jsonText && (returnValue = eval('(' + jsonText + ')')); break; default:returnValue = xhr.responseText }returnValue && opt.success(returnValue) } else opt.error(xhr) } function post (e) { var n = createXHR(); (e = init(e)).type = 'post', !0 === e.async && (n.onreadystatechange = function () { n.readyState == 4 && callback(e, n) }), n.open(e.type, e.url, e.async), n.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded;charset=utf-8'), n.send(e.data), !1 === e.async && callback(e, n) } function get (e) { var n = createXHR(); (e = init(e)).type = 'get', !0 === e.async && (n.onreadystatechange = function () { n.readyState == 4 && callback(e, n) }), e.url += e.url.indexOf('?') == -1 ? '?' + e.data : '&' + e.data, n.open(e.type, e.url, e.async), n.send(null), !1 === e.async && callback(e, n) }opt.type = opt.type.toUpperCase() || 'POST', opt.type === 'POST' ? post(opt) : get(opt) }, BlinkMap = function () { this._entrys = new Array(), this.put = function (e, n) { if (e != null && e != null) { var t = this._getIndex(e); if (t == -1) { var i = new Object(); i.key = e, i.value = n, this._entrys[this._entrys.length] = i } else this._entrys[t].value = n } }, this.get = function (e) { var n = this._getIndex(e); return n != -1 ? this._entrys[n].value : null }, this.remove = function (e) { var n = this._getIndex(e); n != -1 && this._entrys.splice(n, 1) }, this.clear = function () { this._entrys.length = 0 }, this.contains = function (e) { return this._getIndex(e) != -1 }, this.size = function () { return this._entrys.length }, this.getEntrys = function () { return this._entrys }, this._getIndex = function (e) { if (e == null || e == null) return -1; for (var n = this._entrys.length, t = 0; t < n; t++) { var i = this._entrys[t]; if (i != null && i != null && i.key === e) return t } return -1 } }, BlinkException = function (e, n) { this.code = e, this.message = n }, BlinkLogger = {debug: function (e, n) { console.debug(new Date() + ' DEBUG ' + e), n != null && n != null && console.debug(n) }, info: function (e, n) { console.info(new Date() + ' INFO ' + e), n != null && n != null && console.info(n) }, log: function (e, n) { console.log(new Date() + ' LOG ' + e), n != null && n != null && console.log(n) }, warn: function (e, n) { console.warn(new Date() + ' WARN ' + e), n != null && n != null && console.warn(n) }, error: function (e, n) { console.error(new Date() + ' ERROR ' + e), n != null && n != null && console.error(n) }}, RongCallUtil = (pi = function () {}, {ObserverList: function () { var n = function (e, n) { return e > -1 && e < n }; this.observerList = [], this.add = function (e, n) { n && (this.observerList.length = 0), this.observerList.push(e) }, this.get = function (e) { if (n(e, this.observerList.length)) return this.observerList[e] }, this.count = function () { return this.observerList.length }, this.removeAt = function (e) { n(e, this.observerList.length) && this.observerList.splice(e, 1) }, this.remove = function (e) { if (e) { e = Object.prototype.toString.call(e) == '[object Function]' ? [e] : e; for (var n = 0, t = this.observerList.length; n < t; n++) if (this.observerList[n] === e[n]) { this.removeAt(n); break } } else this.observerList.length = 0 }, this.notify = function (e) { for (var n = 0, t = this.observerList.length; n < t; n++) this.observerList[n](e) }, this.indexOf = function (e, n) { for (var t = n || 0, i = this.observerList.length; t < i;) { if (this.observerList[t] === e) return t; t++ } return -1 } }, cache: function () { var t = {}, i = function (e, n) { t[e] = n }; return {set: i, get: function (e) { return t[e] }, update: function (e, n) { i(e, n) }, remove: function (e) { delete t[e] }} }, noop: pi, forEach: function (n, t) { t = t || pi, (typeof n === 'array' ? function () { for (var e = 0; e < n.length; e++)t(n[e], e, n) } : function () { for (var e in n)t(n[e], e, n) })() }, extend: function (e, n) { for (var t in n)e[t] = n[t] }, isNumber: function (e) { return Object.prototype.toString.call(e) == '[object Number]' }}), pi, RongVoIP = (fj = RongCallUtil, gj = {width: 640, height: 480, maxRate: 600, minRate: 450, frameRate: 15}, ij = function (e) { return e }, nj = function (e) { if (!jj) throw new Error('Not call yet, please call first.'); return jj }, {setConfig: function (e) { fj.extend(gj, e) }, joinRoom: function (e, c) { c = c || fj.noop; var n = e.url || ''; (jj = new BlinkEngine(n)).userType = e.userType || '1'; var t = new BlinkEngineEventHandle(), d = null, i = function (e) { var n, t, i, o = e.data, r = e.userId, a = ij(e.userId), s = (n = o, t = a, (i = document.createElement('video')).id = t, i.autoplay = !0, i.controls = !1, i.srcObject = n, i); s.muted = r == kj, s.setAttribute('userid', r); var l = {type: 'added', data: s, talkType: e.talkType, isLocal: e.isLocal}; c(d, l) }, o = function (e) { var n = {type: 'removed', data: e.data, userId: e.userId, isLocal: e.isLocal}; c(d, n) }, r = function () { c(d, {type: 'leave'}) }, a = function () { c(d, {type: 'disconnect'}) }, s = function (e) { var n = {index: 'meet', type: 'hostRemoved', userId: e.userId}; c(d, n) }, l = function (e) { var n = {index: 'meet', type: 'userDown', userId: e.userId}; c(d, n) }, u = function (e) { var n = {index: 'meet', type: 'becomeUser', userId: e.userId}; c(d, n) }, g = function (e) { var n = {index: 'meet', type: 'beRequestToUser', hostId: e.hostId}; c(d, n) }, p = function (e) { var n = {index: 'meet', type: 'reciveRequestToUser', userId: e.userId}; c(d, n) }, f = function (e) { var n = {index: 'meet', type: 'hostRequestControlDevice', userId: e.userId, content: e.content}; c(d, n) }, h = function (e) { var n = {index: 'meet', type: 'whiteBoardURL', url: e.url}; c(d, n) }, m = function (e) { var n = {index: 'meet', type: 'turnTalkType', userId: e.userId, mediaType: e.type, open: e.open}; c(d, n) }, E = function (e) { var n = {index: 'meet', type: 'otherUserBecomeHost', hostId: e.hostId}; c(d, n) }, k = function (e) { var n = {index: 'meet', type: 'userAgreeOpen', mediaType: e.type, userId: e.userId, status: e.status}; c(d, n) }, v = {onJoinComplete: function (e) { console.log('onJoinComplete', e), jj.userType != '2' && {success: function (e) { var n = jj.getLocalVideoView(); y = e.userId, i({userId: y, data: n, isLocal: !0, talkType: e.talkType}) }, error: function () { c('join error.') }}[e.isJoined ? 'success' : 'error'](e) }, onLeaveComplete: function (e) { console.log('onLeaveComplete', e), {success: function () { r(), jj.closeLocalStream(), c(null, e) }, error: function () { c('leave error.') }}[e.isLeft ? 'success' : 'error']() }, onaddstream: function (t) { setTimeout(function () { console.log('onaddstream', t); var e = t.userId; console.info('userID', e); var n = t.stream; i({userId: e, data: n, talkType: t.talkType, isLocal: t.isLocal}) }, 1e3) }, onUserLeft: function (e) { console.log('onUserLeft', e); var n = ij(e.userId); o({data: n, isLocal: !1}) }, onUserUpdatedTalkType: function (e) {}, onConnectionStateChanged: function (e) { e.connectionState === 'DISCONNECTED' && a() }, onHostRemoved: function (e) { s(e) }, onUserDown: function (e) { l(e) }, onBecomeUser: function (e) { u(e) }, onBeRequestToUser: function (e) { g(e) }, OnReciveRequestToUser: function (e) { p(e) }, OnHostRequestControlDevice: function (e) { f(e) }, onShareComplete: function (e) { console.log('onaddstream', e); var n = e.userId; console.info('userID', n); var t = e.stream; i({userId: n, data: t, talkType: e.talkType, isLocal: e.isLocal}) }, onWhiteBoardURL: function (e) { console.log(JSON.stringify(e)), e.isSuccess ? h(e) : console.error('请求白板失败!') }, onNetworkSentLost: function (e) { var n, t = e.packetSendLossRate; (n = t) == null ? $('#signal').css('background-position', '-35px -666px') : n > 45 ? $('#signal').css('background-position', '-203px -666px') : n > 30 ? $('#signal').css('background-position', '-161px -666px') : n > 15 ? $('#signal').css('background-position', '-119px -666px') : n > 5 ? $('#signal').css('background-position', '-77px -666px') : $('#signal').css('background-position', '-35px -666px') }, onTurnTalkType: function (e) { m(e) }, OnOtherUserBecomeHost: function (e) { E(e) }, onUserAgreeOpen: function (e) { k(e) }}; fj.forEach(v, function (e, n) { t.on(n, e) }), jj.setBlinkEngineEventHandle(t); var S = e.channelId; console.info('roomId', S); var y = e.userId, T = {width: gj.width, height: gj.height, frameRate: gj.frameRate}, I = e.mediaType; jj.setVideoParameters({VIDEO_PROFILE: T, VIDEO_MAX_RATE: gj.maxRate, VIDEO_MIN_RATE: gj.minRate, USER_TYPE: 1, IS_CLOSE_VIDEO: {1: function () { return !0 }, 2: function () { return !1 }}[I]()}); var C = e.token; kj = y, console.log('userid,token，userType', y, C, jj.userType), jj.joinChannel(S, y, C) }, quitRoom: function (e) { var n = e.roomId; jj && jj.leaveChannel(n) }, enableAudio: function (e) { var n = !e.isEnabled; nj().updateTalkTypeMic(n) }, enableVideo: function (e) { var n = !e.isEnabled; nj().updateTalkTypeCamera(n) }, getMediaID: function (e) { var n = e.sentTime; return e.senderUserId, String(2147483647 & n) }, getRtcPeer: nj}), jj, kj, fj, gj, ij, nj, MessageCtrl = (fl = [], hl = RongCallUtil, il = hl.ObserverList, kl = function (e, n) { n = n || hl.noop; var t, i, o, r = (t = e, i = {AcceptMessage: RongIMLib.AcceptMessage, RingingMessage: RongIMLib.RingingMessage, SummaryMessage: RongIMLib.SummaryMessage, HungupMessage: RongIMLib.HungupMessage, InviteMessage: RongIMLib.InviteMessage, MediaModifyMessage: RongIMLib.MediaModifyMessage, MemberModifyMessage: RongIMLib.MemberModifyMessage}, o = t.content, new (i[t.messageType] || hl.noop)(o)), a = e.conversationType, s = e.targetId, l = RongIMLib.RongIMClient.getInstance(), c = e.pushText || '', d = e.appData || ''; console.log('im.sendMessage', r), l.sendMessage(a, s, r, {onSuccess: function (e) { fl.unshift(e.messageUId), fl.length > 500 && fl.pop(); n(null, e) }, onError: function (e) { n(e) }}, !1, c, d, null, e) }, ll = {invite: function (e, n) { e.messageType = 'InviteMessage'; var t = e.content, i = t.mediaType, o = t.inviteUserIds, r = {mediaType: i, userIdList: o, callId: t.callId}; e.pushText = {1: '您有一条音频通话', 2: '您有一条视频通话'}[i], e.appData = JSON.stringify(r), e.userIds = o, kl(e, n) }, ringing: function (e, n) { e.messageType = 'RingingMessage', kl(e, n) }, accept: function (e, n) { e.messageType = 'AcceptMessage', kl(e, n) }, hungup: function (e, n) { e.messageType = 'HungupMessage', kl(e, n) }, mediaModify: function (e, n) { e.messageType = 'MediaModifyMessage', kl(e, n) }, memberModify: function (e, n) { e.messageType = 'MemberModifyMessage'; var t = e.content, i = [], o = t.inviteUserIds, r = t.existedMemberStatusList; hl.forEach(o, function (e) { i.push(e) }), hl.forEach(r, function (e) { var n = e.userId; i.push(n) }), e.userIds = i, kl(e, n) }, getToken: function (e, n) { var t = RongIMLib.RongIMClient.getInstance(), i = e.channelId; t.getAgoraDynamicKey(3, i, {onSuccess: function (e) { n(null, e.dynamicKey) }, onError: function (e) { n(e) }}) }}, nl = new il(), RongIMLib.RongIMClient._voipProvider = {onReceived: function (e) { console.log('onRecrived msd', e); var n = fl.indexOf(e.messageUId) > -1; e.offLineMessage || n || nl.notify(e) }}, {sendCommand: function (e, n) { var t = e.command, i = e.data; ll[t] && ll[t](i, n) }, watch: function (e) { nl.add(e) }}), fl, hl, il, kl, ll, nl, RongCallLib = (function () { var T = RongCallUtil, t = RongVoIP.joinRoom, u = RongVoIP.quitRoom, e = RongVoIP.enableAudio, n = RongVoIP.enableVideo, h = RongVoIP.getMediaID, I = MessageCtrl.sendCommand, C = T.cache(), i = T.ObserverList, f = new i(), l = new i(), m = new i(), d = new i(); MessageCtrl.watch(function (e) { d.notify(e) }); function g () { this.timeout = 0, this.startTime = 0, this.start = function (e, n) { n = n || 0, e && (this.timeout = setTimeout(function () { e() }, n)), this.startTime = +new Date() }, this.stop = function (e) { clearTimeout(this.timeout); var n = +new Date(), t = this.startTime; return {start: t, end: n, duration: n - t} } }C.set('videoQueue', {}); var o, E = {}, B = function (a) { var e = a.userIds, s = a.conversationType, l = a.targetId, c = v.currentUserId; T.forEach(e, function (r) { var e = E[r] = new g(), n = r == c || s == 1, t = a.status; e.status = t, e.mediaType = a.mediaType; var i = v.timeout; n || (i += a.timeout || 0); var o = {sent: function (e) { var n = e.status == b.Dialing, t = {conversationType: s, targetId: l, from: 'call-timeout', reasonKey: n ? 'REMOTE_NO_RESPONSE15' : 'NO_RESPONSE5'}, i = C.get('inviteUsers'); W(t, function (e, n) { var t = n.senderUserId; delete i[t] }) }, local: function (e) { var n = L.get('NO_RESPONSE5'), t = C.get('session'), i = {reason: n.code, callId: t.content.channelInfo.Id}, o = {messageType: 'HungupMessage', conversationType: s, targetId: l, senderUserId: r, content: i, messageDirection: 2}; d.notify(o) }}; e.start(function () { o[n ? 'sent' : 'local'](e) }, i) }) }, k = {isActive: !1, init: function (e, n) { this.isActive || (e.url = v.url, e.ices = v.ices, t(e, n), this.isActive = !0) }, reset: function () { this.isActive = !1, C.remove('session') }}, R = function (t) { r(t, function (e, n) { if (e) throw new Error(e); t.token = n; var s = {added: function (e) { var n = e.data, t = n.getAttribute('userid'); e.userId = t, n.setAttribute('userId', t) }}; k.init(t, function (e, n) { if (e) throw new Error(e); if (!n.isLeft) { var t = n.type, i = n.index, o = s[t]; if (o && o(n), i == 'meet')l.notify(n); else { var r = n.sourceId, a = n.userId; if (Number(a) != r)f.notify(n); else C.get('videoQueue')[r] = n } } }) }) }, v = {url: 'https://rtcapi.ronghub.com/nav/websocketlist', timeout: 3e5, ices: [{urls: 'turn:119.254.101.80:3478', credential: 'test', username: 'test'}]}, b = {CallIdle: 0, Dialing: 1, Incoming: 2, Ringing: 3, Active: 4, Hangup: 5}, L = (o = {CANCEL1: {code: 1, info: '己方取消已发出的通话请求'}, REJECT2: {code: 2, info: '己方拒绝收到的通话请求'}, HANGUP3: {code: 3, info: '己方挂断'}, BUSYLINE4: {code: 4, info: '己方忙碌'}, NO_RESPONSE5: {code: 5, info: '己方未接听'}, ENGINE_UN_SUPPORTED6: {code: 6, info: '己方不支持当前引擎'}, NETWORK_ERROR7: {code: 7, info: '己方网络出错'}, OTHER_CLIENT_HANDLED8: {code: 8, info: '其他设备已处理'}, REMOTE_CANCEL11: {code: 11, info: '对方取消已发出的通话请求'}, REMOTE_REJECT12: {code: 12, info: '对方拒绝收到的通话请求'}, REMOTE_HANGUP13: {code: 13, info: '通话过程对方挂断'}, REMOTE_BUSYLINE14: {code: 14, info: '对方忙碌'}, REMOTE_NO_RESPONSE15: {code: 15, info: '对方未接听'}, REMOTE_ENGINE_UN_SUPPORTED16: {code: 16, info: '对方不支持当前引擎'}, REMOTE_NETWORK_ERROR17: {code: 17, info: '对方网络错误'}, VOIP_NOT_AVALIABLE18: {code: 18, info: 'VoIP 不可以用'}}, {get: function (e) { var t; return t = e, T.isNumber(t) && T.forEach(o, function (e, n) { n.indexOf(t) > -1 && (t = n) }), o[e = t] }}), r = function (e, n) { var t = e.channelId; I(e = {command: 'getToken', engineType: 3, data: {channelId: t}}, n) }, A = function (e) { var n = {}; return T.forEach(e, function (e) { n[e] = e }), n }, a = {busy: function (e) { var n = 'BUSYLINE4', t = L.get(n); e.messageDirection == 1 && (n = 'HANGUP3'); var i = {callId: e.content.callId, reason: t.code}, o = e.conversationType, r = e.targetId; I({command: 'hungup', data: {conversationType: o, targetId: r, content: i}}) }, free: function (e, n, t) { m.notify(e), C.set('session', e); var i = e.sentTime, o = e.senderUserId; n ? O({sentTime: i, senderUserId: o}) : e.content.existedUserPofiles.map(function (e) { p(e.userId, e.mediaId) }); var r = e.content, a = r.callId, s = e.conversationType, l = e.targetId, c = r.inviteUserIds; C.set('inviteUsers', A(c)); var d = r.mediaType, u = {conversationType: s, targetId: l, userIds: c, mediaType: d, status: b.Incoming}; if (B(u), t) { u = {conversationType: s, targetId: l, userIds: [e.senderUserId], mediaType: d, status: b.Active}; B(u), M(e), I(u = {command: 'ringing', data: {conversationType: s, targetId: l, content: {callId: a}}}) } }}; function p (e, n) { var t = C.get('session'); return {userId: t[e] = n, sender: t[n] = e} } var s, O = function (e) { var n = e.sentTime, t = e.senderUserId, i = h(e); return console.log('addUserRelation:sentTime->userId', n, '->', t), p(t, i) }, S = new g(), c = 2, y = {single: function (e) { var n = e.senderUserId, t = E[n]; t && t.stop() }, multi: function () { T.forEach(E, function (e) { e.stop() }), C.remove('inviteUsers') }}, M = function (e) { y[e ? 'single' : 'multi'](e) }, N = {1: function () { return L.get('REMOTE_CANCEL11') }, 2: function () { return L.get('REMOTE_REJECT12') }, 3: function () { return L.get('REMOTE_HANGUP13') }, 4: function () { return L.get('REMOTE_BUSYLINE14') }, 5: function () { return L.get('REMOTE_NO_RESPONSE15') }, 15: function () { return L.get('NO_RESPONSE5') }}, U = function (e) { var n = e.conversationType, t = e.targetId, i = C.get('session'), o = i.senderUserId, r = o, a = o, s = i.content, l = s.mediaType, c = s.inviteUserIds, d = {conversationType: n, targetId: t, messageDirection: 2, content: {caller: r, inviter: a, mediaType: l, startTime: 0, duration: 0, status: L.get('OTHER_CLIENT_HANDLED8').code, memberIdList: c}, senderUserId: a, messageType: 'SummaryMessage'}; m.notify(d), C.remove('session') }, _ = {InviteMessage: function (e) { var n = C.get('session'); a[n ? 'busy' : 'free'](e, !0, !0) }, RingingMessage: function (e) { var n = e.senderUserId, t = E[n]; t && (t.stop(), t.status = b.Ringing); var i = C.get('session'); if (i) { var o = i.userOnLine || {}; o[n] = !0, i.userOnLine = o, m.notify(e) } }, AcceptMessage: function (e) { var n, t, i, o, r, a = C.get('session'), s = (a.already, e.senderUserId), l = e.sentTime, c = O({sentTime: l, senderUserId: s}), d = C.get('videoQueue'), u = d[c.userId] || d[c.sender]; if (u && (n = u, t = C.get('videoQueue'), i = n.data, o = i.getAttribute('userid'), r = C.get('session'), o in r && (delete t[o], o = r[o] || o, n.sourceId = o, i.setAttribute('userid', o), f.notify(n))), e.messageDirection == 1)U(e); else { var g = e.content; e.callInfo = {mediaType: g.mediaType, status: b.Active}, M(e); var p = a.content.channelInfo.Id; if ((a.callInfo || {})[p])a.already = !0, S.start(), (E[s] || {}).status = b.Active, m.notify(e) } }, HungupMessage: function (e) { var n = C.get('inviteUsers') || {}, t = e.senderUserId, i = (e.conversationType, C.get('session')); if (i && (o = i.content).channelInfo.Id == e.content.callId) { if (e.callInfo = {mediaType: o.mediaType, status: b.Hangup}, M(e), delete n[t], delete E[t], e.messageDirection == c) { var o, r = (o = e.content).reason; r == 3 && S.startTime == 0 && (r = 2), r = ((N[r] || T.noop)() || {}).code || r, C.set('hungupReason', r) } else U(e); m.notify(e) } }, MediaModifyMessage: function (e) { m.notify(e) }, MemberModifyMessage: function (e) { e.content.existedUserPofiles ? e.content.existedMemberStatusList = e.content.existedUserPofiles : e.content.existedUserPofiles = e.content.existedMemberStatusList, a.free(e, !1, !1) }, otherMessage: function (e) { m.notify(e) }}; s = function (e) { var n = e.messageType; (0, _[n = n in _ ? n : 'otherMessage'])(e) }, d.add(s); var w = function (e, i) { if (C.get('session')) { i(L.get('BUSYLINE4')) } else { var o = e.engineType || 3; C.set(i, e), i = i || T.noop; var n, t, r, c, a, d, u, g, p, f, h, s = e.conversationType, l = e.targetId, m = e.inviteUserIds, E = e.mediaType, k = e.isSharing, v = (n = e, t = Math.floor(1e3 * Math.random()), [n.conversationType, n.targetId, t].join('_')), S = {Key: '', Id: v}, y = {isSharing: k, conversationType: s, targetId: l, content: {sharing: k, engineType: o, inviteUserIds: m, observerUserIds: e.observerUserIds, mediaType: E, callId: v, channelInfo: S}}; c = function (e, n) { if (e.code)i(e); else { var t = n.params; t.engineType = o, R(t) } }, a = (r = y).content, d = a.callId, u = a.mediaType, g = r.isSharing, p = a.inviteUserIds, f = r.conversationType, h = r.targetId, C.set('inviteUsers', A(p)), I({command: 'invite', data: r}, function (e, n) { e && c({code: e}); var t = {}; t[d] = !0, n.callInfo = t, n.isSharing = g; var i = n.sentTime, o = n.senderUserId, r = n.userOnLine = {}; T.forEach(p, function (e) { r[e] = !1 }), C.update('session', n), O({sentTime: i, senderUserId: o}); var a = {code: e}; n.params = {channelId: d, userId: o, sentTime: i, mediaType: u, isSharing: g}, c(a, n); var s = {conversationType: f, targetId: h, userIds: p, timer: 10, mediaType: u, status: b.Dialing}; B(s); var l = {conversationType: f, targetId: h, userIds: [o], timer: 10, mediaType: u, status: b.Active}; B(l), M(n) }) } }, x = function (e, n) { var o = C.get('session'); D({session: o, info: 'Invite: Not call yet'}), n = n || T.noop; o = C.get('session'); var t = e.conversationType, i = e.targetId, r = o.content.callId, a = o.senderUserId, s = e.engineType || 3, l = {Key: '', Id: r}, c = e.mediaType, d = e.inviteUserIds, u = (e.isSharing, []); T.forEach(E, function (e, n) { var t = o[n], i = {userId: n, mediaId: h({sentTime: t, userId: n}), mediaType: e.mediaType, callStatus: e.status}; u.push(i) }); var g = v.currentUserId, p = o[g], f = {userId: g, mediaId: h({sentTime: p, userId: g}), mediaType: c, callStatus: b.Active}; u.map(function (e) { return e.userId }).indexOf(f.userId) < 0 && u.push(f), (function (e, i) { var o = e.content.inviteUserIds, n = C.get('inviteUsers'); T.forEach(o, function (e) { n[e] = e }); var t = {command: 'memberModify', data: e}, r = e.conversationType, a = e.targetId, s = e.content.mediaType; console.log('send memberModify', e), I(t, function (e, n) { n.sentTime, n.senderUserId, i(e = {code: e}, n); var t = {conversationType: r, targetId: a, userIds: o, timer: 10, mediaType: s, status: b.Dialing}; B(t) }) }({conversationType: t, targetId: i, content: {modifyMemType: 1, callId: r, caller: a, engineType: s, channelInfo: l, mediaType: c, inviteUserIds: d, existedMemberStatusList: u, observerUserIds: e.observerUserIds}}, n)) }, D = function (e) { e.session || (function (e) { var n = e.info; throw new Error(n) }(e)) }, P = function (e) { var n = e.conversationType, t = e.targetId, a = e.userType, s = e.mediaType, l = e.isSharing, i = C.get('session'), o = e.from; D({session: i, info: o + ': Not call yet'}); var c = e.engineType, d = i.content, r = d.callId; I(e = {command: 'accept', data: {conversationType: n, targetId: t, content: {callId: r, mediaType: s}}}, function (e, n) { var t = n.sentTime, i = d.callId, o = n.senderUserId; n.callInfo = {mediaType: d.mediaType, status: b.Active}, M(n), O({sentTime: t, senderUserId: o}); var r = {channelId: i, userId: o, sentTime: t, mediaType: s, isSharing: l, engineType: c, userType: a}; E[o].status = b.Active, R(r), S.start() }) }, V = function (e) { e.form = 'accept', P(e) }, H = function (e) { e.form = 'join', P(e) }, j = function (e) { var n = C.get('session'), t = L.get(e.reasonKey), i = n.conversationType, o = n.targetId, r = S.stop(), a = n.senderUserId, s = n.senderUserId, l = n.content, c = l.mediaType, d = l.inviteUserIds, u = n.userOnLine || {}; if (i == 1 && u[a]) { var g = N[t.code]; g && (t = g()) } var p = {conversationType: i, targetId: o, messageDirection: n.messageDirection, content: {caller: a, inviter: s, mediaType: c, startTime: r.start, duration: r.duration, status: t.code, memberIdList: d}, senderUserId: s, messageType: 'SummaryMessage'}; return m.notify(p), k.reset(), C.remove('hungupReason'), p }, W = function (i, o) { o = o || T.noop; var e = C.get('session'), n = i.from; D({session: e, info: n + ': Not call yet'}); var t = t = e.content.callId, r = e.conversationType, a = e.targetId, s = i.reasonKey, l = L.get(s); if (!i.passive) { var c = {command: 'hungup', data: {conversationType: r, targetId: a, content: {callId: t, reason: l.code}}}; I(c, function (e, n) { var t = j(i); o(null, t) }) } else { var d = j(i); o(null, d) }u({roomId: t}), M() }, F = function (e, n) { e.from = 'hungup'; var t = 'CANCEL1'; T.forEach(E, function (e, n) { e.status == b.Active && n != v.currentUserId && (t = 'HANGUP3') }); var i = e.conversationType; e.passive && (t = C.get('hungupReason') || t, i == 3 && (t = E[v.currentUserId].status == b.Active ? 'REMOTE_HANGUP13' : 'NO_RESPONSE5')), e.reasonKey = t, W(e, n) }, G = function (e, n) { (e = e || {}).from = 'reject', e.reasonKey = 'REJECT2', W(e, n) }, K = function () { e({isEnabled: !1}) }, J = function () { e({isEnabled: !0}) }, q = function (e) { var n = C.get('session'), t = n.content.callId, i = (e = e, n.conversationType), o = n.targetId; I({command: 'mediaModify', data: {conversationType: i, targetId: o, content: {callId: t, mediaType: e}}}) }, Y = function () { n({isEnabled: !1}); q(1) }, X = function () { n({isEnabled: !0}); q(2) }, Q = function () { RongVoIP.getRtcPeer().requestWhiteBoardURL() }, $ = function (e) { f.add(e) }, z = function (e) { l.add(e) }, Z = function (e) { m.add(e) }; return {init: function (e) { if (!e.RongIMLib) throw new Error('请引入 Web SDK : http://www.rongcloud.cn/docs/web.html#sdk'); return T.extend(v, e), T.extend(e.RongIMLib.RongIMClient, RongIMLib.RongIMClient), T.extend(RongIMLib, e.RongIMLib), RongVoIP.setConfig(v), {videoWatch: $, commandWatch: Z, call: w, invite: x, hungup: F, reject: G, join: H, mute: K, unmute: J, videoToAudio: Y, audioToVideo: X, accept: V, meetCommandWatche: z, requestWhiteBoardURL: Q, Voip: RongVoIP} }} }()); return RongCallLib }))
